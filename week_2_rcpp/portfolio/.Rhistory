load("solarAU.RData")
head(solarAU)
solarAU$logprod <- log(solarAU$prod+0.01)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
load("solarAU.RData")
setwd("E:/Documents/PhD_TB2/SC2_code/comp_week_3")
load("solarAU.RData")
head(solarAU)
solarAU$logprod <- log(solarAU$prod+0.01)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls_cpp(reg_formula, data = solarAU)
sourceCpp(code='
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
install.packages("Rcpp")
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
install.packages("RcppArmadillo")
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "vsum")]]
NumericVector vsum_I(const NumericVector x1, const NumericVector x2)
{
int ni = x1.size();
NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
d <- 1e5
x1 <- rnorm(d)
x2 <- rnorm(d)
y <- vsum(x1, x2)
max( abs(y - (x1+x2)) )
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "vsum")]]
NumericVector vsum_I(const NumericVector x1, const NumericVector x2)
{
int ni = x1.size();
NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
d <- 1e5
x1 <- rnorm(d)
x2 <- rnorm(d)
y <- vsum(x1, x2)
max( abs(y - (x1+x2)) )
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "vsum")]]
NumericVector vsum_I(const NumericVector x1, const NumericVector x2)
{
int ni = x1.size();
NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
d <- 1e5
x1 <- rnorm(d)
x2 <- rnorm(d)
y <- vsum(x1, x2)
max( abs(y - (x1+x2)) )
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "vsum")]]
Rcpp::NumericVector vsum_I(const Rcpp::NumericVector x1, const Rcpp::NumericVector x2)
{
int ni = x1.size();
Rcpp::NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
d <- 1e5
x1 <- rnorm(d)
x2 <- rnorm(d)
y <- vsum(x1, x2)
max( abs(y - (x1+x2)) )
hello_world()
library(Rcpp)
library(Rcpp)
sourceCpp(code= '
#include<Rcpp.h>
#include<iostream>
// [[Rcpp::export(name="hello_world")]]
void hello_world_I()
{
std::cout << "Hello World" << std::endl;
}
')
hello_world()
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "vsum")]]
Rcpp::NumericVector vsum_I(const Rcpp::NumericVector x1, const Rcpp::NumericVector x2)
{
int ni = x1.size();
Rcpp::NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
x = c(1, 2)
y = c(3, 4)
vsum(x, y)
cppFunction('
cppFunction('
Rcpp::NumericVector vsum_I(const Rcpp::NumericVector x1, const Rcpp::NumericVector x2)
{
int ni = x1.size();
Rcpp::NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
cppFunction('
int fiboInline2(const int x) {
if (x < 2)
return x;
else
return (fiboInline2(x-1)) + fiboInline2(x-2);
}
')
evalCpp(1+1)
evalCpp(for (int i{1}; i < 10; i++) 10+i)
evalCpp('for (int i{1}; i < 10; i++) 10+i')
evalCpp('is_digit(6)')
evalCpp('isdigit(6)')
evalCpp('isdigit("6")')
evalCpp('isdigit('6')')
evalCpp( "std::numeric_limits<double>::max()" )
sourceCpp("pTweedR0_cpp.cpp")
setwd("E:/Documents/PhD_TB2/SC2_code/comp_week_2/portfolio")
sourceCpp("pTweedR0_cpp.cpp")
evalCpp( "std::numeric_limits<double>::max()" )
sourceCpp("pTweedR0_cpp.cpp")
sourceCpp("pTweedR0_cpp.cpp")
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "vsum")]]
Rcpp::NumericVector vsum_I(const Rcpp::NumericVector x1, const Rcpp::NumericVector x2)
{
int ni = x1.size();
Rcpp::NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
sourceCpp("pTweedR0_cpp.cpp")
hello_world_2
hello_world_2()
sourceCpp("pTweedR0_cpp.cpp")
pTweedR0 <- function(y, mu, phi, p, eps = 1e-17, log = FALSE){
# Get param lambda, gamma and alpha to be used in gamma and poisson distrib
la <- mu^(2-p) / ( phi * (2-p) )
ga <- phi * (p-1) * mu^( p-1 )
al <- (2-p) / ( 1-p )
# Mode of Poisson is at k = floor(lambda).
# If mode is 0, we start from 1 instead.
k0 <- max(floor(la), 1)
# Poisson density at its mode
mxlpP <-  dpois(k0, la)
# Get probability contribution at Poisson mode
pTw <- mxlpP * pgamma(y, shape = - k0 * al, scale = ga)
# Initialize k at mode
k <- k0
lP <- mxlpP
# Sum from mode k = floor(lambda) upward until we find kmax
while ( lP > mxlpP * eps ){
k <- k + 1
lP <- dpois(k, la)
pTw <- pTw + lP * pgamma(y, shape = - k * al, scale = ga)
}
kmax <- k
# Reset k to the Poisson mode, and now go down until we find kmin
k <- k0
lP <- mxlpP
while ( lP > mxlpP * eps && k > 0  ){
k <- k - 1
lP <- dpois(k, la)
pTw <- pTw + lP * pgamma(y, shape = - k * al, scale = ga)
}
kmin <- k
if( log ) { pTw <- log( pTw ) }
return( pTw )
}
pTweedR0
# library("tweedie")
nsim <- 1e3
mu <- runif(nsim, 0, 10)
phi <- 0.01 + rexp(nsim, 1)
p <- runif(nsim, 1.001, 1.999)
lpr1 <- lpr2 <- rep(NA, nsim)
for(ii in 1:nsim){
y <- rtweedie(n = 1, mu = mu[ii], phi = phi[ii], power = p[ii])
lpr1[ii] <- pTweedR0(y = y, mu = mu[ii], phi = phi[ii], p = p[ii], log = TRUE)
lpr2[ii] <- log(ptweedie(q = y, mu = mu[ii], phi = phi[ii], power = p[ii]))
}
par(mfrow = c(1, 2))
plot(lpr1, lpr2, xlab = "pTweedR0", ylab = "ptweedie")
abline(0, 1)
plot(lpr1 - lpr2, ylab = "pTweedR0 - ptweedie")
abline(h = 0)
library("tweedie")
nsim <- 1e3
mu <- runif(nsim, 0, 10)
phi <- 0.01 + rexp(nsim, 1)
p <- runif(nsim, 1.001, 1.999)
lpr1 <- lpr2 <- rep(NA, nsim)
for(ii in 1:nsim){
y <- rtweedie(n = 1, mu = mu[ii], phi = phi[ii], power = p[ii])
lpr1[ii] <- pTweedR0(y = y, mu = mu[ii], phi = phi[ii], p = p[ii], log = TRUE)
lpr2[ii] <- log(ptweedie(q = y, mu = mu[ii], phi = phi[ii], power = p[ii]))
}
par(mfrow = c(1, 2))
plot(lpr1, lpr2, xlab = "pTweedR0", ylab = "ptweedie")
abline(0, 1)
plot(lpr1 - lpr2, ylab = "pTweedR0 - ptweedie")
abline(h = 0)
library("tweedie")
install.packages("tweedie")
library("tweedie")
nsim <- 1e3
mu <- runif(nsim, 0, 10)
phi <- 0.01 + rexp(nsim, 1)
p <- runif(nsim, 1.001, 1.999)
lpr1 <- lpr2 <- rep(NA, nsim)
for(ii in 1:nsim){
y <- rtweedie(n = 1, mu = mu[ii], phi = phi[ii], power = p[ii])
lpr1[ii] <- pTweedR0(y = y, mu = mu[ii], phi = phi[ii], p = p[ii], log = TRUE)
lpr2[ii] <- log(ptweedie(q = y, mu = mu[ii], phi = phi[ii], power = p[ii]))
}
par(mfrow = c(1, 2))
plot(lpr1, lpr2, xlab = "pTweedR0", ylab = "ptweedie")
abline(0, 1)
plot(lpr1 - lpr2, ylab = "pTweedR0 - ptweedie")
abline(h = 0)
pTweedR0(y = y, mu = mu[ii], phi = phi[ii], p = p[ii], log = TRUE)
0L
1e1
e
e1
1e
1e1
y
mu
mu[ii]
phi[ii]
p[ii]
dpois(5)
dpois(5, 5)
dpois(5, 5)
dpois(5, 5)
dpois(5, 5)
