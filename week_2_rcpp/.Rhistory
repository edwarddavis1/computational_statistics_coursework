outR = 11.5
inR = 2.75
width = 1.8
vol = pi(11.5^2 + 2.75^2) * width
vol
vol = pi(11.5^2 + 2.75^2) * width
vol = pi * (11.5^2 + 2.75^2) * width
vol
h = 0.2
l = vol / (h * width)
l
l / 1000
outR_E = 0.1
inR_E = 0.1
width_E = 0.1
vol
l * h * width
vol
vol = pi * (11.5^2 - 2.75^2) * width
vol
h = 0.2
l = vol / (h * width)
l / 1000
install.packages("keras")
library(keras)
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
x_test <- mnist$test$x
y_test <- mnist$test$y
library(irlba)
library(Matrix)
n <- 1000
B <- matrix(c(0.2,0.5,
0.5,0.3),2,2)
cp <- c(0.5,0.5)
z <- sample(1:2,n,replace=TRUE,prob=cp)
P <- B[z,z]
A <- matrix(runif(n^2) < P, n, n)
A <- Matrix(A, sparse=TRUE)
e <- irlba(A, 2)
X <- e$u %*% diag(sqrt(e$d))
plot(X)
###########################################
# Two community migration (3 community?)
###########################################
B_ = matrix(c(0.5, 0.5, 0.3,
0.5, 0.5, 0.3,
0.3, 0.3, 0.4),
nrow=3, ncol=3)
mat = matrix(c(0.58, 0.58,
0.58, 0.5),nrow=2)
eigen(mat)
mat2 = matrix(c(0.42, 0.42, 0.42, 0.5, nrow=2))
mat2
mat2 = matrix(c(0.42, 0.42, 0.42, 0.5, nrow=2, ncol=2))
mat2
mat
mat2 = matrix(c(0.42, 0.42, 0.42, 0.5), nrow=2, ncol=2))
mat2 = matrix(c(0.42, 0.42, 0.42, 0.5), nrow=2, ncol=2)
mat2
eigen(mat2)
eigen(mat)
mat3 = matrix(c(-3, 0, -1, 0, -3, 0, -1, 0, -1), nrow=3, ncol=3)
mat3
eigen(mat3)
# Two community stochastic block model
n <- 1000
B <- matrix(c(0.2,0.5,
0.5,0.3),2,2)
cp <- c(0.5,0.5)
z <- sample(1:2,n,replace=TRUE,prob=cp)
P <- B[z,z]
A <- matrix(runif(n^2) < P, n, n)
A <- Matrix(A, sparse=TRUE)
e <- irlba(A, 2)
X <- e$u %*% diag(sqrt(e$d))
library(irlba)
library(Matrix)
# Two community stochastic block model
n <- 1000
B <- matrix(c(0.2,0.5,
0.5,0.3),2,2)
cp <- c(0.5,0.5)
z <- sample(1:2,n,replace=TRUE,prob=cp)
P <- B[z,z]
A <- matrix(runif(n^2) < P, n, n)
A <- Matrix(A, sparse=TRUE)
e <- irlba(A, 2)
X <- e$u %*% diag(sqrt(e$d))
plot(X)
knitr::opts_chunk$set(echo = TRUE)
system("R CMD SHLIB rickerSimul.C")
dyn.load("rickerSimul.so")
setwd("~/Documents/PhD_TB2/comp/comp_week_2")
dyn.load("rickerSimul.so")
system("R CMD SHLIB rickerSimul.C")
dyn.load("rickerSimul.so")
setwd("~/Documents/PhD_TB2/comp/comp_week_2")
knitr::opts_chunk$set(echo = TRUE)
system("R CMD SHLIB rickerSimul.C")
dyn.load("rickerSimul.so")
Ntrue = .Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
# Set variables
nburn <- 100
n <- 50
y0_true <- 1
sig_true <- 0.1
r_true <- 10
# Call the C function
Ntrue = .Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
yobs <- y0_true * exp(rnorm(n, 0, sig_true))
plot(yobs, type = 'b')
library(microbenchmark)
install.packages("microbenchmark")
library(microbenchmark)
rickerSimul_R = function() rickerSimul(as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
rickerSimul_R()
rickerSimul <- function(n, nburn, r, y0 = 1){
y <- numeric(n)
yx <- y0
# Burn in phase
if(nburn > 0){
for(ii in 1:nburn){
yx <- r * yx * exp(-yx)
}
}
# Simulating and storing
for(ii in 1:n){
yx <- r * yx * exp(-yx)
y[ii] <- yx
}
return( y )
}
rickerSimul_R = function() rickerSimul(as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
rickerSimul_R()
rickerSimul_C() = function() .Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
rickerSimul_C() = function() .Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
.Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
rickerSimul_C() <- function() .Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
rickerSimul_C <- function() .Call("rickerSimul", as.integer(n), as.integer(nburn), as.integer(r_true), y0_true)
microbenchmark(rickerSimul_R(), rickerSimul_C(), times = 500)
knitr::opts_chunk$set(echo = TRUE)
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_wrong")]]
NumericVector MMv_I(NumericMatrix A, NumericMatrix B, NumericVector y) {
return A * B * y;
}'
)
load("solarAU.RData")
load("solarAU.RData")
head(solarAU)
library(ggplot2)
library(viridis)
library(ggplot2)
library(viridis)
install.packages("viridis")
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
solarAU$logprod <- log(solarAU$prod+0.01)
solarAU$logprod <- log(solarAU$prod+0.01)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
fit <- lm(logprod ~ tod + I(tod^2) + toy + I(toy^2), data = solarAU)
X <- with(solarAU, cbind(1, tod, tod^2, toy, toy^2))
d <- 3
A <- matrix(1, d, d)
y <- 1:d
MMv_wrong(A, B, y)
install.packages("RccpArmadillo")
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
lm_cpp(y, x)
}
ls(logprod ~ tod + I(tod^2) + toy + I(toy^2), data = solarAU)
fit <- lm(logprod ~ tod + I(tod^2) + toy + I(toy^2), data = solarAU)
fit
library(microbenchmark)
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls(reg_formula, data = solarAU)
# Verify that the function is correct
fit <- lm(reg_formula, data = solarAU)
fit
knitr::opts_chunk$set(echo = TRUE)
load("solarAU.RData")
head(solarAU)
solarAU$logprod <- log(solarAU$prod+0.01)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
# Model matrix
X <- with(solarAU, cbind(1, tod, tod^2, toy, toy^2))
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls_cpp(reg_formula, data = solarAU)
# Verify that the function is correct
fit <- lm(reg_formula, data = solarAU)
fit
library(microbenchmark)
microbenchmark(
R_lm = lm(reg_formula),
C_lm = ls_cpp(reg_formula),
times = 500
)
load("solarAU.RData")
head(solarAU)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
solarAU$logprod <- log(solarAU$prod+0.01)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
# Model matrix
X <- with(solarAU, cbind(1, tod, tod^2, toy, toy^2))
sourceCpp(code='
ourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls_cpp(reg_formula, data = solarAU)
# Verify that the function is correct
fit <- lm(reg_formula, data = solarAU)
fit
library(microbenchmark)
microbenchmark(
R_lm = lm(reg_formula),
C_lm = ls_cpp(reg_formula),
times = 500
)
microbenchmark(
R_lm = lm(reg_formula, data=solarAU),
C_lm = ls_cpp(reg_formula, data=solarAU),
times = 500
)
library(gridExtra)
solarAU$fitPoly <- fit$fitted.values
pl1 <- ggplot(solarAU,
aes(x = toy, y = tod, z = fitPoly)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
pl2 <- ggplot(solarAU,
aes(x = toy, y = tod, z = logprod - fitPoly)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
grid.arrange(pl1, pl2, ncol = 2)
grid.arrange(pl1, pl2, ncol = 2)
grid.arrange(pl1, pl2, ncol = 2)
library(mvtnorm)
lmLocal <- function(y, x0, X0, x, X, H){
w <- dmvnorm(x, x0, H)
fit <- lm(y ~ -1 + X, weights = w)
return( t(X0) %*% coef(fit) )
}
library(mvtnorm)
install.packages("mvtnorm")
library(mvtnorm)
lmLocal <- function(y, x0, X0, x, X, H){
w <- dmvnorm(x, x0, H)
fit <- lm(y ~ -1 + X, weights = w)
return( t(X0) %*% coef(fit) )
}
nrow(solarAU)
n <- nrow(X)
nsub <- 2e3
sub <- sample(1:n, nsub, replace = FALSE)
y <- solarAU$logprod
solarAU_sub <- solarAU[sub, ]
x <- as.matrix(solarAU[c("tod", "toy")])
x0 <- x[sub, ]
X0 <- X[sub, ]
predLocal <- sapply(1:nsub, function(ii){
lmLocal(y = y, x0 = x0[ii, ], X0 = X0[ii, ], x = x, X = X, H = diag(c(1, 0.1)^2))
})
solarAU_sub$fitLocal <- predLocal
pl1 <- ggplot(solarAU_sub,
aes(x = toy, y = tod, z = fitLocal)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
pl2 <- ggplot(solarAU_sub,
aes(x = toy, y = tod, z = logprod - fitLocal)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
grid.arrange(pl1, pl2, ncol = 2)
sourceCpp(code = '
}')
sourceCpp(code = '
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace arma;
vec dmvnInt(mat & X, const rowvec & mu, mat & L)
{
unsigned int d = X.n_cols;
unsigned int m = X.n_rows;
vec D = L.diag();
vec out(m);
vec z(d);
double acc;
unsigned int icol, irow, ii;
for(icol = 0; icol < m; icol++)
{
for(irow = 0; irow < d; irow++)
{
acc = 0.0;
for(ii = 0; ii < irow; ii++) acc += z.at(ii) * L.at(irow, ii);
z.at(irow) = ( X.at(icol, irow) - mu.at(irow) - acc ) / D.at(irow);
}
out.at(icol) = sum(square(z));
}
out = exp( - 0.5 * out - ( (d / 2.0) * log(2.0 * M_PI) + sum(log(D)) ) );
return out;
}')
sourceCpp(code = '
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace arma;
vec dmvnInt(mat & X, const rowvec & mu, mat & L)
{
unsigned int d = X.n_cols;
unsigned int m = X.n_rows;
vec D = L.diag();
vec out(m);
vec z(d);
double acc;
unsigned int icol, irow, ii;
for(icol = 0; icol < m; icol++)
{
for(irow = 0; irow < d; irow++)
{
acc = 0.0;
for(ii = 0; ii < irow; ii++) acc += z.at(ii) * L.at(irow, ii);
z.at(irow) = ( X.at(icol, irow) - mu.at(irow) - acc ) / D.at(irow);
}
out.at(icol) = sum(square(z));
}
out = exp( - 0.5 * out - ( (d / 2.0) * log(2.0 * M_PI) + sum(log(D)) ) );
return out;
}
// [[Rcpp::export(name = "kdeArma")]]
Rcpp::NumericVector kde_i(mat& y, mat& x, mat& H) {
unsigned int n = x.n_rows;
unsigned int m = y.n_rows;
vec out(m, fill::zeros);
mat cholDec = chol(H, "lower");
for(int ii = 0; ii < n; ii++){
out += dmvnInt(y, x.row(ii), cholDec);
}
out /= n;
return Rcpp::wrap(out);
}')
sourceCpp(code = '
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(vec& y, mat& X)
{
mat Q, R;
qr_econ(Q, R, X);
vec beta = solve(R, (trans(Q) * y));
return beta;
}
vec local_lm_I(vec& y, rowvec X0, rowvec X0, mat& x, mat& X, mat& H)
{
// Use Gaussian kernel to get weights
mat H_lower_tri = chol(H, "lower");
vec w = dmvn(x, x0, H_lower_tri);
// local least squares
vec beta = lm_cpp_I(y % sqrt(w), X.each_col() % sqrt(w));
return X0 * beta;
}
// [[Rcpp::export(name = "local_ls_cpp")]]
vec pred_local_I(vec &y, mat x0, mat X0, mat& X, mat& H)
{
vec local_preds(x0.n_rows);
for (int i{0}; i < x0.n_rows; i++) {
rowvec x0_row = x0.row(i);
rowvec X0_row = X0.row(i);
// local_preds(i)
}
}
}')
# STOLEN!!!
sourceCpp(code = '
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
vec dmvnInt(mat & X, const rowvec & mu, mat & L)
{
unsigned int d = X.n_cols;
unsigned int m = X.n_rows;
vec D = L.diag();
vec out(m);
vec z(d);
double acc;
unsigned int icol, irow, ii;
for(icol = 0; icol < m; icol++)
{
for(irow = 0; irow < d; irow++)
{
acc = 0.0;
for(ii = 0; ii < irow; ii++) acc += z.at(ii) * L.at(irow, ii);
z.at(irow) = ( X.at(icol, irow) - mu.at(irow) - acc ) / D.at(irow);
}
out.at(icol) = sum(square(z));
}
out = exp( - 0.5 * out - ( (d / 2.0) * log(2.0 * M_PI) + sum(log(D)) ) );
return out;
}
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(vec& y, mat& X)
{
mat Q, R;
qr_econ(Q, R, X);
vec beta = solve(R, (trans(Q) * y));
return beta;
}
vec local_lm_I(vec& y, rowvec x0, rowvec X0, mat& x, mat& X, mat& H)
{
mat Hstar = chol(H, "lower");
vec w = dmvnInt(x, x0, Hstar);
vec beta = lm_cpp_I(y % sqrt(w), X.each_col() % sqrt(w));
return X0 * beta;
}
// [[Rcpp::export(name="local_lm_fit")]]
vec local_lm_fit_I(vec& y, mat x0, mat X0, mat& x, mat& X, mat& H)
{
int n0 = x0.n_rows;
vec out(n0);
for(int ii=0; ii < n0; ii++)
{
rowvec x00 = x0.row(ii);
rowvec X00 = X0.row(ii);
out(ii) = as_scalar(local_lm_I(y, x00, X00, x, X, H));
if(ii % 50 == 0) {R_CheckUserInterrupt();}
}
return out;
}
}')
