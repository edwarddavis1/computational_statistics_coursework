sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "vsumVett")]]
NumericVector vsum_I(const NumericVector x1, const NumericVector x2)
{
return x1 + x2;
}')
library(Rcpp)
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "vsumVett")]]
NumericVector vsum_I(const NumericVector x1, const NumericVector x2)
{
return x1 + x2;
}')
vsumVett(c(1,2), c(3,4))
# Example: Standard Rcpp
library(Rcpp)
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "vsum")]]
Rcpp::NumericVector vsum_I(const Rcpp::NumericVector x1, const Rcpp::NumericVector x2)
{
int ni = x1.size();
Rcpp::NumericVector out(ni);
for(int ii = 0; ii < ni; ii++){
out[ii] = x1[ii] + x2[ii];
}
return out;
}')
vsum(c(1,2), c(3,4))
vsumVett(c(1,2), c(3,4))
microbenchmark(R = x1 + x2, Rcpp = vsum(x1, x2), RcppSugar = vsumVett(x1, x2))
d <- 1e2
x1 <- rnorm(d)
x2 <- rnorm(d)
microbenchmark(R = x1 + x2, Rcpp = vsum(x1, x2), RcppSugar = vsumVett(x1, x2))
library(microbenchmark)
microbenchmark(R = x1 + x2, Rcpp = vsum(x1, x2), RcppSugar = vsumVett(x1, x2))
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "is_positive)]]
Rcpp::NumericVector is_positive_I(Rcpp::NumericVector num)
{
return num > 0;
}
')
sourceCpp(code = '
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "inRange")]]
LogicalVector inRange_I(const NumericVector x, const NumericVector u, const NumericVector l)
{
return x > l & x < u;
}')
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "is_positive)]]
Rcpp::LogicalVector is_positive_I(Rcpp::NumericVector num)
{
return num > 0;
}
')
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "is_positive")]]
Rcpp::LogicalVector is_positive_I(Rcpp::NumericVector num)
{
return num > 0;
}
')
is_positive(5)
is_positive(-5)
is_positive(5)
is_positive(-5)
sourceCpp(code = '
#include <Rcpp.h>
// [[Rcpp::export(name = "is_equal")]]
Rcpp::LogicalVector is_equal_I(Rcpp::NumericVector num1, Rcpp::NumericVector num2)
{
return num1 == num2;
}
')
is_equal(5, 5)
is_equal(5,6)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2
load("solarAU.RData")
head(solarAU)
solarAU$logprod <- log(solarAU$prod+0.01)
library(ggplot2)
library(viridis)
ggplot(solarAU,
aes(x = toy, y = tod, z = logprod)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
# Chunk 3
# Model matrix
X <- with(solarAU, cbind(1, tod, tod^2, toy, toy^2))
# Chunk 4
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls_cpp(reg_formula, data = solarAU)
# Chunk 5
# Verify that the function is correct
fit <- lm(reg_formula, data = solarAU)
fit
# Chunk 6
library(microbenchmark)
microbenchmark(
R_lm = lm(reg_formula, data=solarAU),
C_lm = ls_cpp(reg_formula, data=solarAU),
times = 500
)
library(gridExtra)
solarAU$fitPoly <- fit$fitted.values
pl1 <- ggplot(solarAU,
aes(x = toy, y = tod, z = fitPoly)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
pl2 <- ggplot(solarAU,
aes(x = toy, y = tod, z = logprod - fitPoly)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
grid.arrange(pl1, pl2, ncol = 2)
library(mvtnorm)
lmLocal <- function(y, x0, X0, x, X, H){
w <- dmvnorm(x, x0, H)
fit <- lm(y ~ -1 + X, weights = w)
return( t(X0) %*% coef(fit) )
}
nrow(solarAU)
n <- nrow(X)
nsub <- 2e3
sub <- sample(1:n, nsub, replace = FALSE)
y <- solarAU$logprod
solarAU_sub <- solarAU[sub, ]
x <- as.matrix(solarAU[c("tod", "toy")])
x0 <- x[sub, ]
X0 <- X[sub, ]
solarAU_sub$fitLocal <- predLocal
pl1 <- ggplot(solarAU_sub,
aes(x = toy, y = tod, z = fitLocal)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
pl2 <- ggplot(solarAU_sub,
aes(x = toy, y = tod, z = logprod - fitLocal)) +
stat_summary_hex() +
scale_fill_gradientn(colours = viridis(50))
grid.arrange(pl1, pl2, ncol = 2)
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls_cpp(reg_formula, data = solarAU)
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
library(Rcpp)
sourceCpp(code='
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
library(RcppArmadillo)
sourceCpp(code='
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name="lm_cpp")]]
arma::vec lm_cpp_I(arma::vec& y, arma::mat& X)
{
arma::mat Q, R;
arma::qr_econ(Q, R, X);
arma::vec beta = solve(R, (trans(Q) * y));
return beta;
}')
ls_cpp = function(formula, data) {
y = data[,all.vars(formula)[1]]
x = model.matrix(formula, data)
# Call C++ function
lm_cpp(y, x)
}
reg_formula = logprod ~ tod + I(tod^2) + toy + I(toy^2)
ls_cpp(reg_formula, data = solarAU)
# Verify that the function is correct
fit <- lm(reg_formula, data = solarAU)
fit
library(microbenchmark)
microbenchmark(
R_lm = lm(reg_formula, data=solarAU),
C_lm = ls_cpp(reg_formula, data=solarAU),
times = 500
)
as.vector(c(1,2) * c(3,4))
library(RcppArmadillo)
library(RcppArmadillo)
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std)]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}
// [[Rcpp::export(name = "MMv_arma)]]
arma::vec MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}
')
MMv_std(c(1,2), c(3,4))
MMv_arma(c(1,2), c(3,4))
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std)]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}
// [[Rcpp::export(name = "MMv_arma)]]
arma::vec MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}
')
library(RcppArmadillo)
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std)]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}
')
sourceCpp(code ='
// [[Rcpp::export(name = "MMv_arma)]]
arma::vec MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}
')
library(RcppArmadillo)
sourceCpp(code='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std)]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}
')
sourceCpp(code ='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_arma)]]
arma::vec MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}
')
library(Rcpp)
sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std)]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}
')
library(Rcpp)
sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std")]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}
')
library(Rcpp)
sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std")]]
NumericMatrix MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}'
)
library(Rcpp)
sourceCpp(code='
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_std")]]
NumericVector MMv_std_I(NumericMatrix A, NumericMatrix B) {
return A * B;
}'
)
library(RcppArmadillo)
sourceCpp(code ='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_arma)]]
arma::vec MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}
')
library(RcppArmadillo)
sourceCpp(code ='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_arma")]]
arma::vec MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}'
)
MMV_std(c(1,2), c(3,4))
MMv_std(c(1,2), c(3,4))
MMv_std(matrix(1,2), matrix(3,4))
matrix(1,2)
A = matrix(c(1,2,3,4), byrow=TRUE, nrow=2)
A
A = matrix(c(1,2,3,4), byrow=TRUE, nrow=2)
B = matrix(c(5,6,7,8), byrow=TRUE, nrow=2)
MMv_std(A, B)
A %*% B
MMv_arma(A, B)
library(RcppArmadillo)
sourceCpp(code ='
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::export(name = "MMv_arma")]]
arma::mat MMv_arma_I(arma::mat& A, arma::mat& B) {
return A * B;
}'
)
MMv_arma(A, B)
MMv_std(A, B)
microbenchmark(R = A %*% B, Arma = MMv_arma(A, B))
# Example: RcppArmadillo speed vs R
library(microbenchmark)
# Large matrices
d <- 1e3
A <- matrix(rnorm(d^2), d, d)
B <- matrix(rnorm(d^2), d, d)
microbenchmark(R = A %*% B, Arma = MMv_arma(A, B))
# Large matrices
d <- 100
A <- matrix(rnorm(d^2), d, d)
B <- matrix(rnorm(d^2), d, d)
microbenchmark(R = A %*% B, Arma = MMv_arma(A, B))
# Large matrices
d <- 1000
A <- matrix(rnorm(d^2), d, d)
B <- matrix(rnorm(d^2), d, d)
microbenchmark(R = A %*% B, Arma = MMv_arma(A, B))
