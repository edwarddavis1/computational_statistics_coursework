---
title: "SC2 RcppPArallel"
author: "Ed Davis"
date: "26/04/2021"
output: html_document
---
=
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Using OpenMP in Rcpp

OpenMP can be included in Rcpp through the use of `[[Rcpp::plugins(openmp)]]`, from here the syntax is the same as in OpenMP. This allows us to write Rcpp code very efficiently by utilising parallelisation. Consider the following code, where the program pauses for four seconds by looping a pause for one second, four times. When we use parallelisation, we set each core to do one loop each, meaning that four cores will each pause for a second simultaneously.   


```{r}
library(Rcpp)

sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>

// [[Rcpp::plugins(openmp)]]

// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{

 #if defined(_OPENMP)
  #pragma omp parallel num_threads(ncores)
  #pragma omp for
 #endif
 for(size_t ii = 0; ii < sec; ii++)
 { 
  sleep(1);
 }
 
 return 1;

 }
')
```

```{r}
# Non-Paralellised vs Parallelised
system.time(wait_a_second_omp(4,1))[3]
system.time(wait_a_second_omp(4,4))[3]
```

The speed up in this case is linear with the number of cores, which is expected. However, this isn't always the case. Certain functions fill cause negligible speed up with more cores (or even a reduced speed) if it casues the cores to compete for computational resources. 





## Rcpp Parallel 
















## Setup 

```{r}
library(electBook)
data(Irish)
```


```{r}
y <- do.call("c", Irish$indCons)
y <- y - mean(y)
```

```{r}
ncust <- ncol(Irish$indCons) 

x <- rep(Irish$extra$tod, ncust)

n <- length(x)
ss <- sample(1:n, 1e4)
plot(x[ss], y[ss], col = "grey")
```

## Univariate Regression

```{r}
# R function for univariate regression
reg1D <- function(y, x){
  b <- t(x) %*% y / (t(x) %*% x)  
  return(b)
}

# Plot
ss <- sort( sample(1:n, 1e4) )
plot(x[ss], y[ss], col = "grey")
abline(a = 0, b = reg1D(y, x), col = 2, lwd = 2)
```

```{r}
# RcppParallel function for univariate regression
library(Rcpp)

sourceCpp(code = '
#include <Rcpp.h>
#include <RcppParallel.h>
using namespace RcppParallel;

struct InnerProduct : public Worker
{
   // source vectors
   const RVector<double> x;
   const RVector<double> y;

   // product that I have accumulated
   double product;

   // constructors
   InnerProduct(const NumericVector x, const NumericVector y)
      : x(x), y(y), product(0) {}
   InnerProduct(const InnerProduct& innerProduct, Split)
      : x(innerProduct.x), y(innerProduct.y), product(0) {}

   void operator()(std::size_t begin, std::size_t end) {
      product += std::inner_product(x.begin() + begin,
                                    x.begin() + end,
                                    y.begin() + begin,
                                    0.0);
   }

   // join my value with that of another InnerProduct
   void join(const InnerProduct& rhs) {
     product += rhs.product;
   }
};

// [[Rcpp::export]]
double parallelInnerProduct(NumericVector x, NumericVector y) {

   // declare the InnerProduct instance that takes a pointer to the vector data
   InnerProduct innerProduct(x, y);

   // call paralleReduce to start the work
   parallelReduce(0, x.length(), innerProduct);

   // return the computed product
   return innerProduct.product;
}

          ')


```

```{r}
library(microbenchmark)

microbenchmark(t(x) %*% y, parallelInnerProduct(t(x) %*% y))
```



































